# Build Plan: BlockBuilder: Drag-and-Drop HTML Tutor for Kids

> This document is the complete implementation reference for this project. It was generated by Innovation Flow from the outputs of five specialist AI agents (solution architect, database specialist, security engineer, UX engineer, analytics expert) and a consolidation step that produced the implementation phases.
>
> **AI agents building this project should treat this as the authoritative technical guide.** Cross-reference with `docs/spec.md` for product requirements and `docs/market-research.md` for market context.

## Tech Stack (Non-Negotiable)

| Layer | Technology |
|-------|------------|
| Framework | Next.js 16 (App Router, React Server Components, Turbopack) |
| Auth | BetterAuth (email/password) |
| Database | NeonDB (serverless Postgres) + Drizzle ORM |
| AI | Azure AI Foundry via Vercel AI SDK (`@ai-sdk/azure`) |
| UI | shadcn/ui, `@dnd-kit`, zustand, recharts, react-markdown, mermaid |
| Hosting | Vercel (serverless) |
| Cache | Upstash Redis |
| Storage | Vercel Blob |
| Monitoring | Sentry |

Do **not** introduce alternative technologies. All implementation must use the stack above.

## Architecture Overview

# BlockBuilder — Architecture Overview

This document describes the high-level architecture for BlockBuilder (MVP scope). It assumes the non-negotiable tech stack: Next.js 16 (App Router + React Server Components + Turbopack), BetterAuth (email/password), NeonDB + Drizzle ORM, Azure AI Foundry via the Vercel AI SDK (@ai-sdk/azure), UI libs (shadcn/ui, @dnd-kit, zustand, recharts, react-markdown, mermaid), hosted on Vercel with Upstash Redis, Vercel Blob, and Sentry.

Key architectural goals (MVP):
- Fast interactive canvas (drag/drop, property panels) on low-end devices
- Safe sandboxed preview (no external network requests from student projects)
- Deterministic one-way block→HTML code generation, autosave & versioning
- Teacher dashboard with class management, CSV/ZIP export, and student submissions
- Accessible, offline-capable (PWA) lesson packs
- Privacy-first telemetry and rate-limited AI hints

C4 System Context (actors and system boundaries)

```mermaid
graph TD
  A[Student (8–14) - Uses Canvas & Lessons] -->|Uses| WebApp[BlockBuilder Web App (Next.js 16)]
  B[Teacher/Parent] -->|Manages classes & views reports| WebApp
  C[Admin] -->|Uploads assets, reviews moderation| WebApp
  subgraph Platform
    WebApp -->|Auth| Auth[BetterAuth (email/password)]
    WebApp -->|Primary DB| DB[NeonDB (Postgres) + Drizzle ORM]
    WebApp -->|AI hints| AzureAI[Azure AI Foundry via Vercel AI SDK (@ai-sdk/azure)]
    WebApp -->|Blob storage| Blob[Vercel Blob]
    WebApp -->|Cache & rate-limits| Redis[Upstash Redis]
    WebApp -->|Monitoring| Sentry[Sentry]
  end
  External[Third-party services blocked from student projects] -.->|Blocked by sandbox & proxy| WebApp
  Note1[Export: single-file HTML/CSS bundle, ZIP export] --> WebApp
  style WebApp fill:#f9f,stroke:#333,stroke-width:2px
```

Container / Component Diagram (major subsystems & interactions)

```mermaid
graph TD
  subgraph Vercel Platform
    A[Next.js App (App Router + RSC + Server Actions + Turbopack)]
    B[Edge Functions (Auth middleware, short latency APIs)]
    C[Serverless Functions (API handlers, file upload presigned, validators)]
    D[Background Jobs (scheduled backups, analytics summarization)]
    E[Vercel Blob]
  end

  A -->|auth flows| BetterAuth[BetterAuth]
  A -->|DB queries (Drizzle)| Neon[NeonDB + Drizzle ORM]
  A -->|cache, rate-limit, queue| Upstash[Upstash Redis]
  A -->|AI requests (server-only via SDK)| Azure[@ai-sdk/azure]
  C -->|store uploaded assets| E
  C -->|validate projects & grade| Neon
  A -->|error telemetry| Sentry[Sentry]

  subgraph Client (Browser)
    UI_Root[Next.js Client Components: Canvas, Property Panel, Toolbar]
    SandboxIFR[Sandboxed iframe (preview)]
    ServiceWorker[Service Worker / PWA cache]
  end

  UI_Root -->|dnd events| @dndkit[@dnd-kit (drag/drop)]
  UI_Root -->|local state| Zustand[Zustand]
  UI_Root -->|send autosave| A
  UI_Root -->|preview update (postMessage/srcdoc)| SandboxIFR
  ServiceWorker -->|serve offline lesson packs| UI_Root

  style A fill:#e3f2fd,stroke:#0d47a1
  style C fill:#fff3e0,stroke:#ef6c00
```

Deployment Topology (how components map to infra)

```mermaid
graph TD
  subgraph Vercel
    edge1[Edge Network / CDN]
    web[Next.js App (Edge + Serverless Lambdas)]
    blob[Vercel Blob Storage]
    functions[Serverless Functions]
    edgeFns[Edge Functions]
  end

  neon[NeonDB (managed serverless Postgres)]
  upstash[Upstash Redis (global managed)]
  azure[Azure AI Foundry (region-bound)]
  better[BetterAuth (Auth provider)]
  sentry[Sentry]

  Client[Browser (Chromebook, tablet, phone)] -->|HTTPS| edge1
  edge1 -->|SSR/Server Components| web
  web -->|DB connection (pooled / serverless best-practices)| neon
  web -->|Redis operations (rate-limits, caching)| upstash
  web -->|AI hints (server-only, proxied)| azure
  web -->|auth API| better
  web -->|blob uploads/downloads (presigned + proxy)| blob
  web -->|error logs| sentry
  Client -->|preview iframe (sandboxed)| functions
  functions -->|asset proxy| blob

  style web fill:#e8f5e9,stroke:#2e7d32
  style neon fill:#fff9c4,stroke:#f9a825
```

Notes on data flows
- Student edits: Client (zustand) -> optimistic client updates -> autosave (Next.js server action to API) -> Neon snapshots & version stored (JSONB) + ephemeral cache in Upstash for immediate UI restoration.
- Preview: client generates canonical AST (blocks tree) and sends minimal snapshot to preview iframe (srcdoc or postMessage). Preview iframe requests assets only through the serverless asset-proxy endpoint which enforces CSP and strips external origins.
- Teacher assignment: Teacher triggers assignment creation -> Next.js server action persists assignment and notifies students via teacher dashboard; exports initiated create ephemeral ZIPs in Vercel Serverless and store in Vercel Blob for retrieval.
- AI hints: client requests hint -> Next.js server handler enforces rate-limit & content filter, then calls Azure AI via @ai-sdk/azure; responses cached in Upstash for identical prompts and anonymized telemetry.



## Data Model

## Security Plan

## UX Plan

## Analytics Plan

## Implementation Phases


Follow these phases in order. Each phase lists concrete tasks that should be completed before moving to the next.


### Phase 1: Foundation & Platform Setup (2 weeks)


**Dependencies:** Access to Vercel org and permissions, BetterAuth account credentials, NeonDB account & credentials, Upstash Redis account & credentials, Azure AI Foundry credentials


- [ ] Create Git monorepo and scaffold Next.js 16 App Router application (TypeScript). Configure Turbopack, ESLint, Prettier, and repo branch protection rules.

- [ ] Install and configure UI/tooling: shadcn/ui, Radix, Tailwind tokens, and establish component/theme token file for design system.

- [ ] Provision and connect Vercel project(s) for dev/staging/prod; add environment variables placeholders for: NEON_DSN, UPSTASH_REDIS_URL/KEY, VERCEL_BLOB_KEY, BETTERAUTH_KEY, AZURE_AI_KEY, SENTRY_DSN, and analytics salts. Add protected deploy approvals on production.

- [ ] Integrate Sentry in both server and client (Next.js server components + client components). Configure initial PII-scrubbing rules and a Sentry environment for staging.

- [ ] Provision NeonDB test & prod instances and create a Drizzle project skeleton. Add drizzle-kit and a CI step in Vercel to run drizzle-kit migrate on deployment.

- [ ] Author initial Drizzle pgTable schema files for core MVP tables (users, projects, project_nodes, project_versions, lessons, classes, assignments, export_jobs, assets, submissions, validation_results, activity_logs) and generate the first migration (drizzle-kit generate --name init_schema). Review SQL for ON DELETE behaviours.

- [ ] Provision Upstash Redis and create two scoped tokens: session-store token and rate-limit token. Add these secrets to Vercel env for dev/staging/prod.

- [ ] Create BetterAuth tenant / app configuration and document sign-up/email templates. Verify webhooks/callbacks and capture API keys; store in Vercel secrets.

- [ ] Create Vercel Blob container and verify presign/upload flow manually via a small serverless route proof-of-concept. Add storage_key naming convention documentation.

- [ ] Register Azure AI Foundry keys and verify access from a Vercel serverless route using @ai-sdk/azure via the Vercel AI SDK; store credentials in Vercel secrets.

- [ ] Add basic CI pipeline: test script, linting, and pre-deploy checks. Fail builds on lint/type errors. Ensure CI does not expose production secrets.



### Phase 2: Core Data Model, Auth & Autosave (3 weeks)


**Dependencies:** Foundation & Platform Setup


- [ ] Finalize and commit Drizzle pgTable definitions for the full schema described (include seed scripts for admin, demo teacher & demo lessons). Add migration to CI and run into dev Neon instance.

- [ ] Implement BetterAuth integration: server-side sign-up/login flows using BetterAuth SDK; wire email verification and password reset flows. Persist metadata in Neon users table (store verification metadata).

- [ ] Implement session management: server-side refresh-token rotation using Upstash Redis as session store (create Redis keys schema: session:{id} -> {userId, ipHash, device, expires}). Create server-side endpoints for refresh, revoke, and list sessions. Set httpOnly Secure SameSite cookie flags as per security plan.

- [ ] Create Next.js middleware for session verification and a lightweight RBAC loader used by Server Components (load user id & role from session; deny access to protected routes).

- [ ] Build autosave backend: Next.js Server Action /app/api/autosave route handler that validates snapshot, writes project_versions (immutable snapshot) and updates projects.autosave_checksum; also write hot snapshot to Upstash for quick restores. Add Zod validation schemas.

- [ ] Client-side: implement zustand editor store skeleton (selectedBlockId, nodes tree, undo/redo, autosave checksum) and local persistence (localStorage + IndexedDB fallback). Implement debounced autosave call to /api/autosave.

- [ ] Implement server-side background job scaffold (Vercel serverless job queue using Upstash Lists/Streams) for snapshot compaction and retention pruning of autosave-only versions.

- [ ] Create DB indexes noted in DB plan (projects(owner_id, updated_at DESC), project_nodes(project_id,parent_id,sort_index), project_versions(project_id,created_at DESC), users(email) UNIQUE). Add migration SQL and run in dev.

- [ ] Write unit tests for session flows, token rotation, autosave endpoint, and Drizzle migrations (migrate + rollback in test DB).



### Phase 3: Editor Canvas & Secure Preview Sandbox (4 weeks)


**Dependencies:** Core Data Model, Auth & Autosave, Vercel Blob provisioned, Asset seeds available in Neon / Vercel Blob


- [ ] Implement client Canvas core: build BlockPalette, Canvas container, CanvasBlock components using @dnd-kit/core + @dnd-kit/sortable. Wire drag/drop, keyboard accessibility for moves, and snapshot updates into zustand store.

- [ ] Implement Property Panel UI (shadcn/ui) with concrete controls: text input, image selector (asset picker), color picker, font-size slider. Persist changes to zustand and trigger debounced autosave.

- [ ] Implement deterministic Blocks-to-HTML code-generator module (shared client/server TypeScript). Produce line mappings (blockId -> lines) used by CodeView mapping.

- [ ] Implement read-only CodeView component (client) with syntax highlight and block->line mapping; clicking code line highlights block in Canvas. Use sanitized code outputs only.

- [ ] Design and implement Preview Sandbox: server-side route handler /api/preview/asset-proxy that serves Vercel Blob assets and enforces CSP & content filtering; client PreviewIframe component renders srcdoc with strict injected CSP (connect-src 'none', default-src 'none'), uses sandbox attributes, and updates via postMessage minimal snapshot deltas.

- [ ] Server-side: implement HTML sanitizer pipeline for preview (DOMPurify or equivalent server-side run) to remove disallowed tags/attributes before embedding in srcdoc; remove external URLs or rewrite to signed blob URLs via asset proxy.

- [ ] Implement lightweight in-iframe handshake: preview sends readiness and DOM-mutation metrics via postMessage to parent; parent logs preview_render_start/complete events (client analytics) and reports slow R.T.s.

- [ ] Add asset manager UI (curated assets) reading assets table from Neon; implement server presign upload for admin/teacher uploads and server-side validation (MIME, size limit, EXIF stripping) on upload completion job.

- [ ] Add performance instrumentation: measure preview_render_time, DOM node counts and send preview_render_complete events to analytics endpoint.

- [ ] Write integration tests for sandbox verifying that outbound network requests are blocked (simulate iframe content attempting fetch) and that asset proxy enforces allowed storage_key only.

- [ ] Add Sentry breadcrumbs/traces for preview errors and instrumented monitoring for sandbox violations (log sandbox_violation events to Neon).



### Phase 4: Teacher Features, Validation & AI Hints (4 weeks)


**Dependencies:** Editor Canvas & Secure Preview Sandbox, Azure AI Foundry credentials and Vercel AI SDK available, Upstash queue token configured, Vercel Blob configured for writes


- [ ] Implement Teacher Dashboard Server Components (Next.js RSC) for classes, roster import (CSV), class join codes and class CRUD. Use Drizzle queries for lists and pagination.

- [ ] Build Teacher client UI (shadcn/ui + recharts): KPI cards, per-class charts (completion rates, avg time-on-task), DataTable for roster and submissions; fetch aggregated metrics endpoints from Neon.

- [ ] Implement Assignments endpoints: /api/assignments (create/list/update) that persist into assignments table and enqueue notifications; implement roster CSV import server action that creates class_memberships and stores audit logs.

- [ ] Implement submission flow: when a student 'submit' action is invoked, create project_version snapshot (source='submission'), create submission row, and trigger validation job.

- [ ] Author Validation/Autograder engine as serverless functions: run lesson.validation_rules against submission snapshot, write validation_results rows and emit challenge_result events. Add simple rule examples and tests.

- [ ] Integrate Azure AI hints via Vercel AI SDK server wrapper: create /api/ai/hint endpoint that accepts sanitized prompt features, enforces Upstash rate-limit per user, performs simple moderation filters, calls @ai-sdk/azure, caches responses in Upstash, and returns anonymized hint payload. Log ai_hint_request events without including PII or raw student code.

- [ ] Implement Export job pipeline: create export_jobs row, enqueue job in Upstash queue, serverless worker generates ZIP/HTML bundles (via JSZip), stores artifact to Vercel Blob, and updates export_jobs.result_url; teacher UI polls job status.

- [ ] Implement teacher per-student timeline UI: list project_versions, allow restore/preview (read-only) and one-click download of single project export.

- [ ] Add server-side audit logging (activity_logs table) for elevated teacher/admin actions: roster imports, exports, impersonation requests. Ensure these writes are transactionally consistent.

- [ ] Write E2E test flows that exercise assignment creation, student submission, autograder results, AI hint request throttling and caching, and export job lifecycle.



### Phase 5: Security Hardening, Analytics & Observability (2 weeks)


**Dependencies:** All previous phases, Security sign-off by product/legal for MFA and retention policies


- [ ] Enforce MFA for teacher/admin accounts via BetterAuth hooks or configured policy; implement TOTP enrollment UI for admins/teachers and backup code generation stored hashed in Neon.

- [ ] Harden Next.js middleware: finalize RBAC/ABAC checks, require re-auth for sensitive actions (exports, roster import), and implement capability tokens for long-running jobs.

- [ ] Implement rate-limiting middleware using Upstash token-bucket patterns for auth endpoints, /api/ai/hint, preview rendering endpoints, and uploads. Add per-IP and per-user counters and dashboard alerts.

- [ ] Implement analytics ingestion endpoint /api/analytics/collect with Zod-validated event schemas (implement the initial event set from analytics plan), store raw events in Neon events_raw table, and short-term counters in Upstash for teacher dashboard fast-paths.

- [ ] Add nightly batch job scaffold (Vercel cron) that aggregates raw events into metrics_daily and populates teacher-facing aggregated tables (beginner path, assigned_lesson_completion). Add job to prune raw events older than retention window (configurable via env).

- [ ] Configure Sentry PII scrubbing and ensure no raw student code or PII is sent (redact email/name fields). Correlate Sentry issue_id in analytics api_error/client_error events.

- [ ] Create DB audit & access controls: create limited DB roles for app_user and migrations_user in Neon, and lock down read/write access in prod secrets; implement retention & deletion stored procedures for activity_logs and old autosaves.

- [ ] Run automated security tests: XSS injection tests, SSRF/preview escape attempts, upload malware pattern tests (simulated), and verify CSP is enforced in preview srcdoc; fail build if critical issues found.



### Phase 6: PWA, Offline, Polish, Testing & Launch Preparation (2 weeks)


**Dependencies:** All previous phases, Legal/compliance sign-off for pilot, Pilot school accounts available to test COPPA flows


- [ ] Implement Service Worker & PWA registration: cache lesson content, curated assets, and editor shell for offline reads. Add IndexedDB writer for local edits while offline and conflict resolution UI (last-write wins + teacher review).

- [ ] Finalize accessibility fixes: run automated Axe CI, address high/critical issues, implement keyboard drag alternative and ARIA live regions for validation and autosave notices.

- [ ] Complete end-to-end test suite (Playwright): critical flows (signup, editor create/block drag, preview sandbox blocking, autosave/restore, submit+autograder, teacher export). Include tests that assert CSP headers and blocked external requests.

- [ ] Performance tuning and SLO validation: measure preview_render_median_ms and P95 on representative devices (Chromebook/tablet). Address hotspots (virtualize large canvas lists, memoize heavy components).

- [ ] Finalize production migrations and run a dry-run migration in staging; run seed script for demo teacher/student/lessons and curated assets in staging.

- [ ] Operationalize launch checklist: rotate prod keys, confirm Neon PITR backups, configure monitoring & PagerDuty for critical alerts (sandbox_violation spikes, high error rates), configure Sentry release tracking, and set Upstash alerting for Redis errors.

- [ ] Prepare compliance artifacts: DPA template, COPPA/FERPA flow documentation, parental consent storage proof, data retention policy, incident response runbook; have legal sign-off.

- [ ] Soft-launch: deploy to a pilot cohort, enable analytics opt-in for teachers, collect UAT feedback, triage issues and perform final patch release window prior to full launch.



## Architecture Decision Records


### ADR-1: Use Next.js 16 App Router with React Server Components and Server Actions


**Context:** The product requires fast initial loads, server-rendered lesson pages, privacy-sensitive server-side operations (AI calls, DB mutations), and fine-grained interactivity (canvas). Next.js 16 App Router and Server Components let us keep data fetching on the server and ship minimal JS to the client.


**Decision:** Adopt Next.js 16 App Router as the single application framework. Use React Server Components (RSC) for data-heavy pages (lessons, dashboards), and Client Components for the interactive canvas, preview shell, and small UI controls. Use Server Actions for mutations (autosave, submit, teacher operations). Build with Turbopack for faster local/dev builds.


**Consequences:** Positive: minimal client JS for lesson pages, easier data access in server components, tighter security (server AI calls). Negative: developers must be disciplined about Server vs Client components; some third-party browser-only libraries need to be wrapped as Client Components. Server Actions require explicit 'use server' and careful error handling for idempotency.



### ADR-2: Auth via BetterAuth (email/password) with HTTP-only session cookies


**Context:** Auth must be non-negotiable: BetterAuth (email/password) is mandated. Sessions must be safe for schools and support teacher/parent roles, and SSR pages must be able to validate auth without client fetches.


**Decision:** Integrate BetterAuth as the primary authentication provider. Use Next.js middleware and route handlers to validate session tokens server-side. Store session tokens in HTTP-only, Secure cookies scoped per domain. Use role claims (teacher, student, admin) embedded in tokens and verify on each server action. For SSO/LMS later, plan to extend with BetterAuth provider hooks (but not in MVP).


**Consequences:** Positive: Simple, familiar email/password for pilot classrooms and clear server-side checks for RSCs. Negative: Must ensure BetterAuth supports required compliance (COPPA/GDPR) — legal review required. Also requires careful cookie and CSRF handling for server actions.



### ADR-3: Primary DB: NeonDB (serverless Postgres) with Drizzle ORM


**Context:** NeonDB is fixed. We need typed, maintainable DB access with migrations and ability to store both relational data (users, classes) and hierarchical block ASTs + versioning snapshots.


**Decision:** Use drizzle-orm to model domain tables and perform type-safe queries. Schema design: keep relational entities normalized (users, classrooms, enrollments, lessons, assignments, badges), use JSONB columns for canonical block AST (projects.current_ast JSONB) and a versions table projects_versions(project_id, snapshot JSONB, created_by, created_at). Blocks tree will be primarily held in the canonical AST JSONB; for searches and validation we maintain extracted indices (e.g., has_image boolean column) updated via server actions or background compaction jobs. Use drizzle-kit for migrations.


**Consequences:** Positive: Type-safe queries and migration support accelerate dev. JSONB lets us evolve AST shape without heavy schema churn and stores full snapshots for versioning. Negative: JSONB-heavy workloads require careful indexing and compaction to avoid bloat. Serverless connection handling must be implemented with a singleton pattern for Drizzle client to avoid connection exhaustion (Neon serverless model supports ephemeral connections but code must reuse clients across invocations where possible).



### ADR-4: AI Hints via Azure AI Foundry through Vercel AI SDK (@ai-sdk/azure) with server-side wrapper and caching


**Context:** Product requires AI-generated hints but AI usage must be controlled (privacy, safety, rate-limiting, deterministic behavior). The tech constraint mandates Azure AI Foundry via the Vercel AI SDK.


**Decision:** All AI calls will be executed server-side only via a dedicated API route (Next.js route handler) that wraps @ai-sdk/azure. The wrapper will: validate & sanitize the prompt payload, apply strict prompt templates, enforce rate-limits (Upstash), perform content filtering (server rules & heuristics), and cache responses for identical prompts in Upstash Redis for TTL of e.g., 24 hours. The client calls a server endpoint that returns the cached/validated response.


**Consequences:** Positive: Controlled, auditable AI usage with minimal PII; caching reduces costs and latency. Negative: Increased server latency when cold; must monitor cost of Azure AI. Also prompts must be carefully designed to avoid hallucinations; limit types of hints in MVP (explanations, code diffs, context-aware suggestions) rather than full code generation.



### ADR-5: Hosting & Deployment on Vercel (Serverless + Edge Functions + Vercel Blob)


**Context:** Hosting is constrained to Vercel. We need a mix of SSR, serverless API routes, edge functions for low-latency auth checks and CSP headers, and durable blob storage.


**Decision:** Deploy the Next.js app to Vercel. Use Edge Functions for auth middleware, CSP header injection, and fast public endpoints. Use Serverless Functions (Next.js Route Handlers) for asset presigning, export generation (ZIP), AI proxy (server wrapper), and heavy validations. Use Vercel Blob for storing uploaded assets and exported ZIPs.


**Consequences:** Positive: Seamless CI/CD, global CDN, and integrated Blob storage simplifies the stack. Negative: Vercel serverless functions have cold start and memory limits; long-running jobs must be chunked or offloaded to simple queue-driven workers (Upstash-based) to avoid timeouts. Also data residency concerns require Neon + Vercel region planning.



### ADR-6: Asset Uploads & Sandboxed Preview using Asset Proxy and CSP


**Context:** Student project previews must be sandboxed and must not allow arbitrary external network requests. We must also support teacher-approved assets and safe uploads.


**Decision:** Model uploads via presigned Vercel Blob URLs for admin/teacher uploads only in MVP. For student uploads (if enabled), server route will presign upload and enforce server-side validation (size, MIME). In preview, the iframe's HTML will reference assets only through our serverless asset-proxy endpoint (URL pattern /api/asset-proxy/:id) which streams blob content and sets restrictive CSP and content-type headers. The iframe will be sandboxed (sandbox attribute) and the server will set CSP headers to block connect-src, frame-ancestors, form-action other than same-origin. All external URLs in a student's generated HTML will be removed or rewritten to the asset proxy during generation.


**Consequences:** Positive: Strong sandboxing reduces security risk and meets the 'no external network requests' requirement. Negative: Asset proxy increases server bandwidth and adds cost; must implement caching (Upstash or CDN) for frequent requests. Also large-scale asset storage will need lifecycle policies to control cost.



### ADR-7: Autosave, Versioning & Snapshot Strategy


**Context:** Students must have autosave & versioning. Teachers must be able to review submissions and previous attempts. Snapshots can be frequent and large (AST JSONB), so storage & retrieval must be efficient.


**Decision:** Autosave pings from the client will be throttled (e.g., every 5–10s or on major actions) and sent as diffs when feasible. Server stores the latest hot snapshot in Upstash Redis for instant restores and persists periodic full snapshots to Neon (projects_versions table) for teacher review. A background compaction job will keep only N snapshots per project by default (configurable) and keep key checkpoints (first publish, teacher submission, milestone). Use Drizzle to persist snapshots in JSONB with created_by & metadata.


**Consequences:** Positive: Fast recovery with Upstash and persistent history in Neon. Negative: Snapshot retention requires storage planning and compaction logic to avoid runaway DB growth.



### ADR-8: API Style: Server Actions + Route Handlers (REST-like) — no real-time sockets for MVP


**Context:** MVP does not require real-time multi-user editing; strong consistency for autosave & teacher actions is required. Next.js provides Server Actions and route handlers out-of-the-box.


**Decision:** Use Server Actions for student-initiated operations (autosave, local saves, property updates) and Route Handlers for file uploads, exports, teacher reports, and AI calls. Keep endpoints REST-like with clear idempotency semantics. Avoid websockets in MVP to reduce complexity; teacher dashboards will poll or use short-polling/edge functions to update classroom state within sub-5s targets.


**Consequences:** Positive: Simplifies server infrastructure and developer experience. Negative: Teacher dashboard updates might be slightly less real-time; polling intervals must be tuned to balance freshness vs cost.



### ADR-9: State Management: zustand for client, server components for source-of-truth


**Context:** Canvas interactions must feel snappy with low-latency updates. Some state (project snapshot) must be persisted and authoritative on server.


**Decision:** Use zustand as the canonical client-side transient state for the canvas and UI. The server (RSCs) holds authoritative project state in Neon. Sync patterns: optimistic-local updates with periodic server autosave via Server Actions. On reconnect, reconcile server snapshot by diffing ASTs server-side and present merge UI if conflicts exist (teacher review fallback for MVP).


**Consequences:** Positive: Minimal boilerplate, lightweight and performant client state. Negative: Conflict resolution must be implemented carefully; for MVP we prefer last-write wins with teacher review rather than complex CRDT sync.



### ADR-10: Drag & Drop Implementation using @dnd-kit with nesting & performance optimizations


**Context:** A robust nesting model and high responsiveness (<=200ms interactions) are required. @dnd-kit is mandated in the stack.


**Decision:** Use @dnd-kit/core + @dnd-kit/sortable for drag/drop interactions. Implement nesting rules in a dedicated ‘nesting policy’ module that validates allowed parent/child relationships and drag previews. For performance: use requestAnimationFrame, memoized components, virtualization for long lists, and only send high-frequency changes to local zustand store (not to server).


**Consequences:** Positive: Rich, accessible DnD with keyboard sensors and good performance if care is taken. Negative: Complex nesting logic must be well-tested; dragging large document trees may need rendering optimizations.



### ADR-11: Charts & Analytics with recharts (client) and privacy-first aggregation server-side


**Context:** Teacher dashboards and product analytics need charts. Tech stack mandates recharts.


**Decision:** Use recharts in client dashboard components for visualization. Aggregate raw events server-side (Neon) with sampling/rollback for PII reduction. Export analytics CSVs via server functions.


**Consequences:** Positive: Fast client-side charts and consistent behavior across browsers. Negative: Large datasets should be downsampled server-side, and charts may need pagination/aggregation to keep client performance stable.



### ADR-12: Monitoring & Error Tracking with Sentry


**Context:** Need to capture client and server errors, performance bottlenecks, and regressions during pilots.


**Decision:** Integrate Sentry SDK in both client & server code paths. Capture uncaught exceptions, performance traces for server handlers, and custom breadcrumbs for AI calls, exports, or sandbox failures. Respect privacy: do NOT send student content or PII to Sentry; scrub or hash content before sending.


**Consequences:** Positive: Rapid diagnosis of production issues. Negative: Must implement strict PII-scrubbing pipeline to avoid leaking student data.

